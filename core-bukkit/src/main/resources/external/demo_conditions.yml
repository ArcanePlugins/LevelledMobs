# Brainstorming Rule Conditions for LM 4.
conditions:

  #########
  ### NOTES
  #########
  #
  # - SHORT/LONG VERSIONS OF CONDITIONS
  #   Each condition, wherever feasible, will have a short version
  #   of the normal (long) version. This helps simplify longer files
  #   and remove repetitive boilerplate. However, it is recommended
  #   to use the long (normal) version wherever feasible as there is
  #   less room for error and it is easier to configure to a degree.
  #
  # - GRAVE SYMBOL (`) IN KEYS, IN THE BRAINSTORMING FILE
  #   To prevent errors in the editor from duplicate YAML
  #   keys, the grave symbol (`) is added to prevent duplicate
  #   keys from existing. Of course these duplicate keys will
  #   not happen in the actual file, and these symbols are not
  #   used in the real file.
  #
  # - INCLUSIVE/EXCLUSIVE PRIORITY
  #   Inclusive lists have priority over exclusive lists.
  #
  # - INVERSING CONDITIONS
  #   All block-conditions (not short hand versions!) have
  #   a boolean called 'inverse'. This inverts the boolean
  #   output of the condition. This can be used in funky ways
  #   e.g. using an inclusive list but inverting it so it is
  #   actually exclusive ;) of course this is not intended,
  #   it is meant to be used for conditions that don't have
  #   incl/excl functionality.
  #   This is per-condition! Not per-rule.

  ##############
  # ENTITY TYPES
  ##############
  # Specify a list of Entity Types which are required
  # for the rule to be processed.

  # short, inclusive
  entity-types-incl: ['CREEPER'] # only creepers

  # short, exclusive
  entity-types-excl: ['CREEPER'] # all except creepers

  # long
  entity-types:
    inclusive-list: ['CREEPER'] # Set<String> - only creepers
    # OR
    exclusive-list: ['CREEPER'] # Set<String> - all except creepers

  ####################
  # MOB LEVELLED STATE
  ####################
  # Specify whether the mob should be levelled/not levelled
  # or if this should be ignored.
  # 'ANY' = the mob can be levelled or not levelled (default)
  # 'YES' = the mob must be levelled
  # 'NO'  = the mob must not be levelled

  # short
  levelled-state: 'ANY' # String (LevelledState)

  # long
  levelled-state`:
    type: 'ANY' # String (LevelledState)

  ########################
  # LIGHT LEVEL FROM BLOCK
  ########################
  # Specify a min-to-max requirement of what the mob's
  # current location's block's light level is for the rule.
  #
  # Light level from blocks is not the same as light level from the sky!
  #
  # A short, non-ranged version will not be added. it'll
  # just bloat the parser and be harder to use anyways.
  # Just use the short-ranged or long verison.

  # short
  light-level-from-block: '3-5' # RangedInt - requires block light level min=3 to max=5.

  # long
  light-level-from-block`:
    min: 3
    max: 5

  ######################
  # LIGHT LEVEL FROM SKY
  ######################
  # Specify a min-max requirement of what the mob's
  # current location's sky light level is for that rule.
  #
  # Light level from the sky is not the same as light level from blocks!
  #
  # Same layout as the light level from block condition. See that condition's
  # brainstorming comments for more information.

    # short
    light-level-from-sky: '3-5' # RangedInt - requires sky light level min=3 to max=5.

    # long
    light-level-from-sky`:
      min: 3
      max: 5