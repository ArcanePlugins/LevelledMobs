Index: src/main/java/io/github/lokka30/levelledmobs/listeners/CreatureSpawnListener.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>package io.github.lokka30.levelledmobs.listeners;\r\n\r\nimport io.github.lokka30.levelledmobs.LevelManager;\r\nimport io.github.lokka30.levelledmobs.LevelledMobs;\r\nimport io.github.lokka30.levelledmobs.enums.ModalList;\r\nimport io.github.lokka30.levelledmobs.utils.Utils;\r\nimport org.bukkit.attribute.Attribute;\r\nimport org.bukkit.entity.Ageable;\r\nimport org.bukkit.entity.Creeper;\r\nimport org.bukkit.entity.EntityType;\r\nimport org.bukkit.entity.LivingEntity;\r\nimport org.bukkit.event.EventHandler;\r\nimport org.bukkit.event.EventPriority;\r\nimport org.bukkit.event.Listener;\r\nimport org.bukkit.event.entity.CreatureSpawnEvent;\r\nimport org.bukkit.event.entity.CreatureSpawnEvent.SpawnReason;\r\nimport org.bukkit.event.entity.EntitySpawnEvent;\r\nimport org.bukkit.persistence.PersistentDataType;\r\n\r\nimport java.util.Arrays;\r\nimport java.util.List;\r\nimport java.util.Random;\r\nimport java.util.concurrent.ThreadLocalRandom;\r\nimport java.util.regex.Matcher;\r\n\r\npublic class CreatureSpawnListener implements Listener {\r\n\r\n    private final LevelledMobs instance;\r\n\r\n    public CreatureSpawnListener(final LevelledMobs instance) {\r\n        this.instance = instance;\r\n    }\r\n\r\n    /**\r\n     * This listens for entities that are not passed thrrough CreatureSpawnEvent,\r\n     * such as Phantoms and Ender Dragons, which server owners may want to have levelled.\r\n     *\r\n     * @param event EntitySpawnEvent, the event to listen to\r\n     */\r\n    @EventHandler(ignoreCancelled = true, priority = EventPriority.MONITOR)\r\n    public void onEntitySpawn(final EntitySpawnEvent event) {\r\n        if (!(event.getEntity() instanceof LivingEntity)) return;\r\n\r\n        LivingEntity livingEntity = (LivingEntity) event.getEntity();\r\n\r\n        List<EntityType> forcedTypes = Arrays.asList(EntityType.ENDER_DRAGON, EntityType.PHANTOM);\r\n        if (forcedTypes.contains(event.getEntityType())) {\r\n            processMobSpawn(livingEntity, SpawnReason.DEFAULT, -1);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Thos listens to most mobs that spawn in.\r\n     *\r\n     * @param event CreatureSpawnEvent, the event to listen to\r\n     */\r\n    @EventHandler(ignoreCancelled = true, priority = EventPriority.MONITOR)\r\n    public void onCreatureSpawn(final CreatureSpawnEvent event) {\r\n        // spawned using summon command.  It will get processed directly\r\n        if (event.getSpawnReason() == SpawnReason.CUSTOM) return;\r\n\r\n        processMobSpawn(event.getEntity(), event.getSpawnReason(), -1);\r\n    }\r\n    \r\n    public void processMobSpawn(final LivingEntity livingEntity, final SpawnReason spawnReason, int level) {\r\n\r\n        //Check if the mob is already levelled\r\n        if (livingEntity.getPersistentDataContainer().get(instance.levelManager.levelKey, PersistentDataType.INTEGER) != null) {\r\n            return;\r\n        }\r\n\r\n        // if spawned naturally it will be -1.  If used summon with specific level specified then it will be >= 0\r\n        if (level == -1) {\r\n\t        //Check settings for spawn distance levelling and choose levelling method accordingly.\r\n            if (instance.hasWorldGuardInstalled && instance.worldGuardManager.checkRegionFlags(livingEntity)) {\r\n                level = generateRegionLevel(livingEntity);\r\n            } else if (instance.settingsCfg.getBoolean(\"spawn-distance-levelling.active\")) {\r\n                level = generateDistanceFromSpawnLevel(livingEntity);\r\n            } else {\r\n                level = generateLevel(livingEntity);\r\n            }\r\n        }\r\n\r\n        if (instance.settingsCfg.getBoolean(\"debug-show-spawned-mobs\")) {\r\n            boolean isAdult = !(livingEntity instanceof Ageable) || ((Ageable) livingEntity).isAdult();\r\n            if (isAdult)\r\n                Utils.logger.info(String.format(\"Spawned a &fLvl.%s &b%s &8(&7Adult&8)\", level, livingEntity.getName()));\r\n            else\r\n                Utils.logger.info(String.format(\"Spawned a &fLvl.%s &b%s &8(&7Baby&8)\", level, livingEntity.getName()));\r\n        }\r\n\r\n        if (instance.levelManager.isLevellable(livingEntity)) {\r\n\r\n            //Check the 'worlds list' to see if the mob is allowed to be levelled in the world it spawned in\r\n            if (!ModalList.isEnabledInList(instance.settingsCfg, \"allowed-worlds-list\", livingEntity.getWorld().getName())) {\r\n                return;\r\n            }\r\n\r\n            //Check the list of blacklisted spawn reasons. If the entity's spawn reason is in there, then we don't continue.\r\n            //Uses a default as \"NONE\" as there are no blocked spawn reasons in the default config.\r\n            if (!ModalList.isEnabledInList(instance.settingsCfg, \"allowed-spawn-reasons-list\", spawnReason.toString())) {\r\n                return;\r\n            }\r\n\r\n            // change child level to match parent.  Only possible from parsing the custom number for the level number\r\n            if (spawnReason == SpawnReason.SLIME_SPLIT) {\r\n                if (instance.settingsCfg.getBoolean(\"slime-children-retain-level-of-parent\")) {\r\n                    // [Level 10 | Slime]\r\n\r\n                    Matcher m = instance.levelManager.slimeRegex.matcher(instance.levelManager.getNametag(livingEntity));\r\n                    if (m.find() && m.groupCount() >= 1) {\r\n                        // the only reason it won't match is if someone has changed the custom name syntax significantly\r\n                        String probablyLevelNum = m.group(1);\r\n                        if (Utils.isInteger(probablyLevelNum))\r\n                            level = Integer.parseInt(probablyLevelNum);\r\n                    }\r\n\r\n                    // if we didn't match then the slime will get a random level instead of the parent's level\r\n                }\r\n            }\r\n\r\n            // if spawned naturally it will be -1.  If used summon with specific level specified or if using the slime child system then it will be >= 0\r\n            if (level == -1) {\r\n                //Check settings for spawn distance levelling and choose levelling method accordingly.\r\n                if (instance.hasWorldGuardInstalled && instance.worldGuardManager.checkRegionFlags(livingEntity)) {\r\n                    level = generateRegionLevel(livingEntity);\r\n                } else if (instance.settingsCfg.getBoolean(\"spawn-distance-levelling.active\")) {\r\n                    level = generateDistanceFromSpawnLevel(livingEntity);\r\n                } else {\r\n                    level = generateLevel(livingEntity);\r\n                }\r\n            }\r\n\r\n            //Define the mob's level so it can be accessed elsewhere.\r\n            livingEntity.getPersistentDataContainer().set(instance.levelManager.levelKey, PersistentDataType.INTEGER, level);\r\n            livingEntity.getPersistentDataContainer().set(instance.levelManager.isLevelledKey, PersistentDataType.STRING, \"true\");\r\n\r\n            // Max Health attribute\r\n            if (livingEntity.getAttribute(Attribute.GENERIC_MAX_HEALTH) != null) {\r\n                double multiplier = instance.settingsCfg.getDouble(\"fine-tuning.additions.attributes.max-health\");\r\n                instance.attributeManager.setAddedValue(livingEntity, Attribute.GENERIC_MAX_HEALTH, multiplier, level);\r\n                //noinspection ConstantConditions\r\n                livingEntity.setHealth(livingEntity.getAttribute(Attribute.GENERIC_MAX_HEALTH).getBaseValue());\r\n            }\r\n\r\n            // Movement Speed attribute\r\n            if (livingEntity.getAttribute(Attribute.GENERIC_MOVEMENT_SPEED) != null) {\r\n                double multiplier = instance.settingsCfg.getDouble(\"fine-tuning.additions.attributes.movement-speed\");\r\n                instance.attributeManager.setAddedValue(livingEntity, Attribute.GENERIC_MOVEMENT_SPEED, multiplier, level);\r\n            }\r\n\r\n            // Attack Damage attribute\r\n            if (livingEntity.getAttribute(Attribute.GENERIC_ATTACK_DAMAGE) != null) {\r\n                double multiplier = instance.settingsCfg.getDouble(\"fine-tuning.additions.attributes.attack-damage\");\r\n                instance.attributeManager.setAddedValue(livingEntity, Attribute.GENERIC_ATTACK_DAMAGE, multiplier, level);\r\n            }\r\n\r\n            if (livingEntity instanceof Creeper && instance.settingsCfg.getInt(\"creeper-max-damage-radius\", 3) != 3) {\r\n\r\n                // level 1 ends up with 3 (base) and anything higher becomes a percent of the max radius as specified in the config\r\n                int blastRadius = (int) Math.floor(level / 10.0 * ((double) instance.settingsCfg.getInt(\"creeper-max-damage-radius\")) - 3) + 3;\r\n\r\n                // even at 100 creepers are atomic bombs but at least won't blow up the entire world\r\n                if (blastRadius > LevelManager.maxCreeperBlastRadius) {\r\n                    blastRadius = LevelManager.maxCreeperBlastRadius;\r\n                }\r\n                if (level == 1) {\r\n                    blastRadius = 3;\r\n                } // level 1 creepers will always have default radius\r\n                else if (level == 0 && blastRadius > 2) {\r\n                    blastRadius = 2;\r\n                } // level 0 will always be less than default\r\n\r\n                ((Creeper) livingEntity).setExplosionRadius(blastRadius);\r\n            }\r\n\r\n            //Update their tag.\r\n            final String nameTag;\r\n            if (level == 1 && !instance.settingsCfg.getBoolean(\"show-label-for-default-levelled-mobs\")) {\r\n                nameTag = \"\";\r\n            } else {\r\n                nameTag = instance.levelManager.getNametag(livingEntity, level);\r\n            }\r\n            instance.levelManager.updateNametag(livingEntity, nameTag);\r\n\r\n        } else if (spawnReason == CreatureSpawnEvent.SpawnReason.CURED) {\r\n            //Check if a zombie villager was cured. If villagers aren't levellable, then their name will be cleared,\r\n            //otherwise their nametag is still 'Zombie Villager'. That doesn't seem right...\r\n            instance.levelManager.updateNametag(livingEntity, \"\");\r\n        }\r\n    }\r\n\r\n    //Generates a level.\r\n    //Uses ThreadLocalRandom.current().nextInt(min, max + 1). + 1 is because ThreadLocalRandom is usually exclusive of the uppermost value.\r\n    public Integer generateLevel(final LivingEntity livingEntity) {\r\n\r\n        boolean isAdult = !(livingEntity instanceof Ageable) || ((Ageable) livingEntity).isAdult();\r\n\r\n        if (instance.settingsCfg.getBoolean(\"y-distance-levelling.active\")){\r\n            return generateYCoordinateLevel(\r\n                    livingEntity.getLocation().getBlockY(),\r\n                    instance.configUtils.getMinLevel(livingEntity.getType(), livingEntity.getWorld(), isAdult),\r\n                    instance.configUtils.getMaxLevel(livingEntity.getType(), livingEntity.getWorld(), isAdult)\r\n            );\r\n        }\r\n\r\n        // normal return:\r\n        return ThreadLocalRandom.current().nextInt(\r\n                instance.configUtils.getMinLevel(livingEntity.getType(),\r\n                        livingEntity.getWorld(), isAdult),\r\n                instance.configUtils.getMaxLevel(livingEntity.getType(),\r\n                        livingEntity.getWorld(), isAdult) + 1\r\n        );\r\n    }\r\n\r\n    //Generates a level based on distance to spawn and, if active, variance\r\n    private Integer generateDistanceFromSpawnLevel(final LivingEntity livingEntity) {\r\n        boolean isAdult = !(livingEntity instanceof Ageable) || ((Ageable) livingEntity).isAdult();\r\n        final int minLevel = instance.configUtils.getMinLevel(livingEntity.getType(), livingEntity.getWorld(), isAdult);\r\n        final int maxLevel = instance.configUtils.getMaxLevel(livingEntity.getType(), livingEntity.getWorld(), isAdult);\r\n\r\n        //Get distance between entity spawn point and world spawn\r\n        final int entityDistance = (int) livingEntity.getWorld().getSpawnLocation().distance(livingEntity.getLocation());\r\n\r\n        //Make mobs start leveling from start distance\r\n        int levelDistance = entityDistance - instance.settingsCfg.getInt(\"spawn-distance-levelling.start-distance\");\r\n        if (levelDistance < 0) levelDistance = 0;\r\n\r\n        //Get the level thats meant to be at a given distance\r\n        int finalLevel = (levelDistance / instance.settingsCfg.getInt(\"spawn-distance-levelling.increase-level-distance\")) + minLevel;\r\n\r\n        //Check if there should be a variance in level\r\n        if (instance.settingsCfg.getBoolean(\"spawn-distance-levelling.variance.enabled\")) {\r\n            //The minmum amount of variation.\r\n            final int minVariation = instance.settingsCfg.getInt(\"spawn-distance-levelling.variance.min\");\r\n\r\n            //The maximum amount of variation.\r\n            final int maxVariation = instance.settingsCfg.getInt(\"spawn-distance-levelling.variance.max\");\r\n\r\n            //A random number between min and max which determines the amount of variation that will take place\r\n            final int change = ThreadLocalRandom.current().nextInt(minVariation, maxVariation + 1);\r\n\r\n            //Start variation. First check if variation is positive or negative towards the original level amount.\r\n            if (ThreadLocalRandom.current().nextBoolean()) {\r\n                //Positive. Add the variation to the final level\r\n                finalLevel = finalLevel + change;\r\n            } else {\r\n                //Negative. Subtract the variation from the final level\r\n                finalLevel = finalLevel - change;\r\n            }\r\n        }\r\n\r\n        //Ensure the final level is within level min/max caps\r\n        if (finalLevel > maxLevel) {\r\n            finalLevel = maxLevel;\r\n        }\r\n        else if (finalLevel < minLevel) {\r\n            finalLevel = minLevel;\r\n        }\r\n\r\n        return finalLevel;\r\n    }\r\n\r\n    private int generateRegionLevel(final LivingEntity livingEntity) {\r\n        boolean isAdult = !(livingEntity instanceof Ageable) || ((Ageable) livingEntity).isAdult();\r\n        final int[] levels = instance.worldGuardManager.getRegionLevel(livingEntity,\r\n                instance.configUtils.getMinLevel(livingEntity.getType(), livingEntity.getWorld(), isAdult),\r\n                instance.configUtils.getMaxLevel(livingEntity.getType(), livingEntity.getWorld(), isAdult));\r\n\r\n        if (!instance.settingsCfg.getBoolean(\"y-distance-levelling.active\")){\r\n            // standard issue, generate random levels based upon max and min flags in worldguard\r\n            return levels[0] + Math.round(new Random().nextFloat() * (levels[1] - levels[0]));\r\n        }\r\n\r\n        // generate level based on y distance but use min and max values from world guard\r\n        return generateYCoordinateLevel(livingEntity.getLocation().getBlockY(), levels[0], levels[1]);\r\n    }\r\n\r\n    private int generateYCoordinateLevel(final int mobYLocation, final int minLevel, final int maxLevel) {\r\n        final int yPeriod = instance.settingsCfg.getInt(\"y-distance-levelling.y-period\", 0);\r\n        final int variance = instance.settingsCfg.getInt(\"y-distance-levelling.variance\", 0);\r\n        int yStart = instance.settingsCfg.getInt(\"y-distance-levelling.starting-y-level\", 100);\r\n        int yEnd = instance.settingsCfg.getInt(\"y-distance-levelling.ending-y-level\", 20);\r\n\r\n        final boolean isAscending = (yEnd > yStart);\r\n        if (!isAscending) {\r\n            yStart = yEnd;\r\n            yEnd = instance.settingsCfg.getInt(\"y-distance-levelling.starting-y-level\", 100);\r\n        }\r\n\r\n        if (mobYLocation <= yStart){\r\n            return isAscending ? minLevel : maxLevel;\r\n        }\r\n        else if (mobYLocation > yEnd){\r\n            return isAscending ? maxLevel : minLevel;\r\n        }\r\n\r\n        final double diff = yEnd - yStart;\r\n        double useMobYLocation = mobYLocation - yStart;\r\n        int useLevel;\r\n\r\n        if (yPeriod > 0){\r\n            useLevel = (int)(useMobYLocation / (double) yPeriod);\r\n        }\r\n        else {\r\n            if (useMobYLocation < yStart) {\r\n                useMobYLocation = 1.0;\r\n            } else if (useMobYLocation > yEnd) {\r\n                useMobYLocation = yEnd;\r\n            }\r\n\r\n            useLevel = (int) Math.ceil(useMobYLocation / diff * maxLevel);\r\n        }\r\n\r\n        if (variance > 0){\r\n            final int change = ThreadLocalRandom.current().nextInt(0, variance);\r\n            //Start variation. First check if variation is positive or negative towards the original level amount.\r\n            if (ThreadLocalRandom.current().nextBoolean()) {\r\n                //Positive. Add the variation to the final level\r\n                useLevel += change;\r\n            } else {\r\n                //Negative. Subtract the variation from the final level\r\n                useLevel -= change;\r\n            }\r\n        }\r\n\r\n        if (!isAscending) {\r\n            useLevel = maxLevel - useLevel + 1;\r\n        }\r\n\r\n        if (useLevel < minLevel){ useLevel = minLevel; }\r\n        else if (useLevel > maxLevel){ useLevel = maxLevel; }\r\n\r\n        return useLevel;\r\n    }\r\n}\r\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- src/main/java/io/github/lokka30/levelledmobs/listeners/CreatureSpawnListener.java	(revision 0b9f0fd036d476615a01bc8985f9b71f98b5b289)
+++ src/main/java/io/github/lokka30/levelledmobs/listeners/CreatureSpawnListener.java	(date 1610927636688)
@@ -181,12 +181,12 @@
             } else {
                 nameTag = instance.levelManager.getNametag(livingEntity, level);
             }
-            instance.levelManager.updateNametag(livingEntity, nameTag);
+            instance.levelManager.updateNametagWithDelay(livingEntity, nameTag);
 
         } else if (spawnReason == CreatureSpawnEvent.SpawnReason.CURED) {
             //Check if a zombie villager was cured. If villagers aren't levellable, then their name will be cleared,
             //otherwise their nametag is still 'Zombie Villager'. That doesn't seem right...
-            instance.levelManager.updateNametag(livingEntity, "");
+            instance.levelManager.updateNametagWithDelay(livingEntity, "");
         }
     }
 
Index: src/main/java/io/github/lokka30/levelledmobs/LevelManager.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>package io.github.lokka30.levelledmobs;\r\n\r\nimport com.comphenix.protocol.PacketType;\r\nimport com.comphenix.protocol.ProtocolLibrary;\r\nimport com.comphenix.protocol.events.PacketContainer;\r\nimport com.comphenix.protocol.wrappers.WrappedChatComponent;\r\nimport com.comphenix.protocol.wrappers.WrappedDataWatcher;\r\nimport io.github.lokka30.levelledmobs.enums.ModalList;\r\nimport io.github.lokka30.levelledmobs.listeners.CreatureSpawnListener;\r\nimport io.github.lokka30.levelledmobs.utils.Utils;\r\nimport me.lokka30.microlib.MicroUtils;\r\nimport org.bukkit.Bukkit;\r\nimport org.bukkit.NamespacedKey;\r\nimport org.bukkit.attribute.Attribute;\r\nimport org.bukkit.attribute.AttributeInstance;\r\nimport org.bukkit.entity.*;\r\nimport org.bukkit.inventory.ItemStack;\r\nimport org.bukkit.persistence.PersistentDataType;\r\nimport org.bukkit.scheduler.BukkitRunnable;\r\n\r\nimport java.lang.reflect.InvocationTargetException;\r\nimport java.util.*;\r\nimport java.util.regex.Pattern;\r\n\r\npublic class LevelManager {\r\n\r\n    private final LevelledMobs instance;\r\n\r\n    public LevelManager(LevelledMobs instance) {\r\n        this.instance = instance;\r\n\r\n        levelKey = new NamespacedKey(instance, \"level\");\r\n        isLevelledKey = new NamespacedKey(instance, \"isLevelled\");\r\n\r\n        /*\r\n        ProtocolLibrary.getProtocolManager().addPacketListener(new PacketAdapter(instance, ListenerPriority.NORMAL, PacketType.Play.Server.ENTITY_METADATA) {\r\n            @Override\r\n            public void onPacketSending(PacketEvent event) {\r\n                if (event.getPacketType() != PacketType.Play.Server.ENTITY_METADATA) return;\r\n\r\n                PacketContainer packet = event.getPacket();\r\n\r\n\r\n                final Entity entity = packet.getEntityModifier(event).read(0);\r\n\r\n                if(!(entity instanceof LivingEntity)) return;\r\n\r\n                final LivingEntity livingEntity = (LivingEntity) entity;\r\n\r\n                if(!livingEntity.getPersistentDataContainer().has(isLevelledKey, PersistentDataType.STRING)) return;\r\n\r\n                WrappedDataWatcher dataWatcher = WrappedDataWatcher.getEntityWatcher(entity).deepClone();\r\n                WrappedDataWatcher.Serializer chatSerializer = WrappedDataWatcher.Registry.getChatComponentSerializer(true);\r\n                WrappedDataWatcher.WrappedDataWatcherObject watcherObject = new WrappedDataWatcher.WrappedDataWatcherObject(2, chatSerializer);\r\n                Optional<Object> optional = Optional.of(WrappedChatComponent.fromChatMessage(getNametag(livingEntity))[0].getHandle());\r\n                dataWatcher.setObject(watcherObject, optional);\r\n                dataWatcher.setObject(3, true);\r\n\r\n                packet.getWatchableCollectionModifier().write(0, dataWatcher.getWatchableObjects());\r\n                packet.getIntegers().write(0, entity.getEntityId());\r\n\r\n                event.setPacket(packet);\r\n            }\r\n        });\r\n\r\n         */\r\n\r\n    }\r\n\r\n    public final NamespacedKey levelKey; // This stores the mob's level.\r\n    public final NamespacedKey isLevelledKey; //This is stored on levelled mobs to tell plugins that it is a levelled mob.\r\n\r\n    public final EnumSet<EntityType> forcedTypes = EnumSet.of(EntityType.GHAST, EntityType.MAGMA_CUBE, EntityType.HOGLIN, EntityType.SHULKER, EntityType.PHANTOM, EntityType.ENDER_DRAGON);\r\n\r\n    public final static int maxCreeperBlastRadius = 100;\r\n    public final Pattern slimeRegex = Pattern.compile(\"Level.*?(\\\\d{1,2})\", Pattern.CASE_INSENSITIVE);\r\n    public CreatureSpawnListener creatureSpawnListener;\r\n\r\n    public boolean isLevellable(final EntityType entityType) {\r\n        // Don't level these\r\n        if (entityType == EntityType.PLAYER || entityType == EntityType.UNKNOWN) return false;\r\n\r\n        // Check if the entity is overriden. If so, force it to be levelled.\r\n        if (instance.settingsCfg.getStringList(\"overriden-entities\").contains(entityType.toString())) return true;\r\n\r\n        // Check if the entity is blacklisted. If not, continue.\r\n        if(!ModalList.isEnabledInList(instance.settingsCfg, \"allowed-entities-list\", entityType.toString())) return false;\r\n\r\n        // These entities don't implement Monster or Boss and thus must be forced to return true\r\n        if (forcedTypes.contains(entityType)) {\r\n            return true;\r\n        }\r\n\r\n        // Grab the Entity class, which is used to check for certain assignments\r\n        Class<? extends Entity> entityClass = entityType.getEntityClass();\r\n        if (entityClass == null) return false;\r\n\r\n        return Monster.class.isAssignableFrom(entityClass)\r\n                || Boss.class.isAssignableFrom(entityClass)\r\n                || instance.settingsCfg.getBoolean(\"level-passive\");\r\n    }\r\n\r\n    //Checks if an entity can be levelled.\r\n    public boolean isLevellable(final LivingEntity entity) {\r\n\r\n        //Players shouldn't be levelled! Keep this at the top to ensure they don't return true\r\n        if (entity.getType() == EntityType.PLAYER || entity.getType() == EntityType.UNKNOWN || entity.hasMetadata(\"NPC\")) {\r\n            return false;\r\n        }\r\n\r\n        // Check WorldGuard flag.\r\n        if (instance.hasWorldGuardInstalled && !instance.worldGuardManager.regionAllowsLevelling(entity)) return false;\r\n\r\n        // Check for overrides\r\n        if(instance.settingsCfg.getStringList(\"overriden-entities\").contains(entity.getType().toString())) return true;\r\n\r\n        //Check allowed entities for normal entity types\r\n        if(!ModalList.isEnabledInList(instance.settingsCfg, \"allowed-entities-list\", entity.getType().toString())) return false;\r\n\r\n        // Specific allwoed entities check for BABY_ZOMBIE\r\n        if(entity instanceof Zombie) {\r\n            final Zombie zombie = (Zombie) entity;\r\n            if(!zombie.isAdult()) {\r\n                if(!ModalList.isEnabledInList(instance.settingsCfg, \"allowed-entities-list\", \"BABY_ZOMBIE\")) return false;\r\n            }\r\n        }\r\n\r\n        return isLevellable(entity.getType());\r\n    }\r\n\r\n    //Updates the entity's nametag after a 1 tick delay. Without the delay, it would\r\n    //display the entity's previous health rather than their new health.\r\n    //Used on EntityDamageEvent and EntityRegainHealthEvent.\r\n    public void updateNametagWithDelay(LivingEntity entity) {\r\n        new BukkitRunnable() {\r\n            public void run() {\r\n                if (entity == null) return; // may have died 1 tick later.\r\n\r\n                updateNametag(entity, getNametag(entity));\r\n            }\r\n        }.runTaskLater(instance, 1L);\r\n    }\r\n\r\n    //Calculates the drops when a levellable creature dies.\r\n    public void setLevelledDrops(final LivingEntity ent, List<ItemStack> drops) {\r\n\r\n        if (isLevellable(ent)) {\r\n            //If mob is levellable, but wasn't levelled, return.\r\n            Integer level = ent.getPersistentDataContainer().get(instance.levelManager.levelKey, PersistentDataType.INTEGER);\r\n            if (level == null)\r\n                return;\r\n\r\n            //Read settings for drops.\r\n            double dropMultiplier = instance.settingsCfg.getDouble(\"fine-tuning.additions.custom.item-drop\");\r\n            int finalMultiplier = 1;\r\n\r\n            //If multiplier * level gurantees an extra drop set 'finalMultiplier' to the amount of safe multiples.\r\n            dropMultiplier *= level;\r\n            finalMultiplier += (int) dropMultiplier;\r\n            dropMultiplier -= (int) dropMultiplier;\r\n\r\n            //Calculate if the remaining extra drop chance triggers.\r\n            double random = new Random().nextDouble();\r\n            if (random < dropMultiplier) {\r\n                finalMultiplier++;\r\n            }\r\n\r\n            //Remove the hand item from the mob's drops so it doesn't get multiplied\r\n            ItemStack helmet = null;\r\n            ItemStack chestplate = null;\r\n            ItemStack leggings = null;\r\n            ItemStack boots = null;\r\n            ItemStack mainHand = null;\r\n            ItemStack offHand = null;\r\n            if (ent.getEquipment() != null) {\r\n                helmet = ent.getEquipment().getHelmet();\r\n                chestplate = ent.getEquipment().getChestplate();\r\n                leggings = ent.getEquipment().getLeggings();\r\n                boots = ent.getEquipment().getBoots();\r\n                mainHand = ent.getEquipment().getItemInMainHand();\r\n                offHand = ent.getEquipment().getItemInOffHand();\r\n            }\r\n\r\n            //Edit the ItemStacks to drop the calculated multiple items.\r\n            for (int i = 0; i < drops.size(); i++) {\r\n                ItemStack itemStack = drops.get(i);\r\n\r\n                int amount = itemStack.getAmount() * finalMultiplier;\r\n\r\n                //Don't let the drops go over the max stack size.\r\n                int maxStackSize = itemStack.getMaxStackSize();\r\n                if (amount > maxStackSize) {\r\n                    amount = maxStackSize;\r\n                }\r\n\r\n                //Don't let the plugin multiply items which match their equipment. stops bows and that from multiplying\r\n                if (helmet != null && itemStack.isSimilar(helmet)) {\r\n                    amount = helmet.getAmount();\r\n                }\r\n                if (chestplate != null && itemStack.isSimilar(chestplate)) {\r\n                    amount = chestplate.getAmount();\r\n                }\r\n                if (leggings != null && itemStack.isSimilar(leggings)) {\r\n                    amount = leggings.getAmount();\r\n                }\r\n                if (boots != null && itemStack.isSimilar(boots)) {\r\n                    amount = boots.getAmount();\r\n                }\r\n                if (mainHand != null && itemStack.isSimilar(mainHand)) {\r\n                    amount = mainHand.getAmount();\r\n                }\r\n                if (offHand != null && itemStack.isSimilar(offHand)) {\r\n                    amount = offHand.getAmount();\r\n                }\r\n\r\n                itemStack.setAmount(amount);\r\n                drops.set(i, itemStack);\r\n            }\r\n        }\r\n    }\r\n\r\n    //Calculates the XP dropped when a levellable creature dies.\r\n    public int setLevelledXP(final LivingEntity ent, int xp) {\r\n        if (ent.getPersistentDataContainer().has(isLevelledKey, PersistentDataType.STRING)) {\r\n            double xpPerLevel = instance.settingsCfg.getDouble(\"fine-tuning.additions.custom.xp-drop\");\r\n            int level = Objects.requireNonNull(ent.getPersistentDataContainer().get(instance.levelManager.levelKey, PersistentDataType.INTEGER));\r\n\r\n            xp = (int) (xp + (xpPerLevel * level));\r\n        }\r\n        return xp;\r\n    }\r\n\r\n    // When the persistent data container levelled key has been set on the entity already (i.e. when they are damaged)\r\n    public String getNametag(LivingEntity livingEntity) {\r\n        return getNametag(livingEntity, Objects.requireNonNull(\r\n                livingEntity.getPersistentDataContainer().get(levelKey, PersistentDataType.INTEGER)));\r\n    }\r\n\r\n    // When the persistent data container levelled key has not been set on the entity yet (i.e. for use in CreatureSpawnListener)\r\n    public String getNametag(LivingEntity livingEntity, int level) {\r\n        String entityName = livingEntity.getCustomName() == null ? instance.configUtils.getEntityName(livingEntity.getType()) : livingEntity.getCustomName();\r\n\r\n        AttributeInstance maxHealth = livingEntity.getAttribute(Attribute.GENERIC_MAX_HEALTH);\r\n        String health = maxHealth == null ? \"?\" : maxHealth.getBaseValue() + \"\";\r\n\r\n        String nametag = instance.settingsCfg.getString(\"creature-nametag\");\r\n        nametag = Utils.replaceEx(nametag, \"%level%\", level + \"\");\r\n        nametag = Utils.replaceEx(nametag, \"%name%\", entityName);\r\n        nametag = Utils.replaceEx(nametag, \"%health%\", Utils.round(livingEntity.getHealth()) + \"\");\r\n        nametag = Utils.replaceEx(nametag, \"%max_health%\", health);\r\n        nametag = Utils.replaceEx(nametag, \"%heart_symbol%\", \"❤\");\r\n        assert nametag != null;\r\n        nametag = MicroUtils.colorize(nametag);\r\n\r\n        return nametag;\r\n    }\r\n\r\n    /*\r\n     * Credit\r\n     * - Thread: https://www.spigotmc.org/threads/changing-an-entitys-nametag-with-packets.482855/\r\n     *\r\n     * - Users:\r\n     *   - @CoolBoy (https://www.spigotmc.org/members/CoolBoy.102500/)\r\n     *   - @Esophose (https://www.spigotmc.org/members/esophose.34168/)\r\n     *   - @7smile7 (https://www.spigotmc.org/members/7smile7.43809/)\r\n     */\r\n    public void updateNametag(LivingEntity entity, String nametag) {\r\n\r\n        WrappedDataWatcher dataWatcher = WrappedDataWatcher.getEntityWatcher(entity).deepClone();\r\n        WrappedDataWatcher.Serializer chatSerializer = WrappedDataWatcher.Registry.getChatComponentSerializer(true);\r\n        WrappedDataWatcher.WrappedDataWatcherObject watcherObject = new WrappedDataWatcher.WrappedDataWatcherObject(2, chatSerializer);\r\n        Optional<Object> optional = Optional.of(WrappedChatComponent.fromChatMessage(nametag)[0].getHandle());\r\n        dataWatcher.setObject(watcherObject, optional);\r\n        dataWatcher.setObject(3, true);\r\n\r\n        PacketContainer packet = ProtocolLibrary.getProtocolManager().createPacket(PacketType.Play.Server.ENTITY_METADATA);\r\n        packet.getWatchableCollectionModifier().write(0, dataWatcher.getWatchableObjects());\r\n        packet.getIntegers().write(0, entity.getEntityId());\r\n\r\n        for (Player onlinePlayer : Bukkit.getOnlinePlayers()) {\r\n            try {\r\n                ProtocolLibrary.getProtocolManager().sendServerPacket(onlinePlayer, packet);\r\n            } catch (InvocationTargetException ex) {\r\n                Utils.logger.error(\"Unable to update nametag packet for player &b\" + onlinePlayer.getName() + \"&7! Stack trace:\");\r\n                ex.printStackTrace();\r\n                return;\r\n            }\r\n        }\r\n    }\r\n}\r\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- src/main/java/io/github/lokka30/levelledmobs/LevelManager.java	(revision 0b9f0fd036d476615a01bc8985f9b71f98b5b289)
+++ src/main/java/io/github/lokka30/levelledmobs/LevelManager.java	(date 1610927636667)
@@ -128,15 +128,19 @@
         return isLevellable(entity.getType());
     }
 
-    //Updates the entity's nametag after a 1 tick delay. Without the delay, it would
-    //display the entity's previous health rather than their new health.
+    //Updates the livingEntity's nametag after a 1 tick delay. Without the delay, it would
+    //display the livingEntity's previous health rather than their new health.
     //Used on EntityDamageEvent and EntityRegainHealthEvent.
-    public void updateNametagWithDelay(LivingEntity entity) {
+    public void updateNametagWithDelay(LivingEntity livingEntity) {
+        updateNametagWithDelay(livingEntity, getNametag(livingEntity));
+    }
+
+    public void updateNametagWithDelay(LivingEntity livingEntity, String nametag) {
         new BukkitRunnable() {
             public void run() {
-                if (entity == null) return; // may have died 1 tick later.
+                if (livingEntity == null) return; // may have died 1 tick later.
 
-                updateNametag(entity, getNametag(entity));
+                updateNametag(livingEntity, nametag);
             }
         }.runTaskLater(instance, 1L);
     }
